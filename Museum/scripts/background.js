import*as THREE from"three";export const bgShaderMaterial=new THREE.ShaderMaterial({uniforms:{uTime:{value:0},uResolution:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},uCameraRotation:{value:(new THREE.Matrix3).identity()},skyColor:{value:new THREE.Vector3(.01,.01,.01)},starBaseColor:{value:new THREE.Vector3(.8,1,.3)},starHueOffset:{value:.6},starIntensity:{value:.08},starTwinkleSpeed:{value:.8},starTwinkleIntensity:{value:.2},layerScale:{value:20},layerScaleStep:{value:10},layersCount:{value:6}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    precision highp float;\n\n    #define PI 3.14159265359\n    #define TAU 6.28318530718\n    #define USE_TWINKLE\n\n    uniform float uTime;\n    uniform vec2 uResolution;\n    uniform mat3 uCameraRotation; // New uniform\n\n    uniform vec3 skyColor;\n    uniform vec3 starBaseColor;\n    uniform float starHueOffset;\n    uniform float starIntensity;\n    uniform float starTwinkleSpeed;\n    uniform float starTwinkleIntensity;\n    uniform float layerScale;\n    uniform float layerScaleStep;\n    uniform int layersCount;\n\n    varying vec2 vUv;\n\n    // Hash function based on Inigo Quilezâ€™s work.\n    vec3 hash(vec3 p) {\n      p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n               dot(p, vec3(269.5, 183.3, 246.1)),\n               dot(p, vec3(113.5, 271.9, 124.6)));\n      return fract(sin(p) * 43758.5453123);\n    }\n\n    // 3D Voronoi cell distance calculation.\n    vec2 voronoi(vec3 x) {\n      vec3 p = floor(x);\n      vec3 f = fract(x);\n      float res = 100.0;\n      float id = 0.0;\n      for (float k = -1.0; k <= 1.0; k += 1.0) {\n        for (float j = -1.0; j <= 1.0; j += 1.0) {\n          for (float i = -1.0; i <= 1.0; i += 1.0) {\n            vec3 b = vec3(i, j, k);\n            vec3 r = b - f + hash(p + b);\n            float d = dot(r, r);\n            if(d < res) {\n              res = d;\n              id = dot(p + b, vec3(0.0, 57.0, 113.0));\n            }\n          }\n        }\n      }\n      return vec2(sqrt(res), id);\n    }\n\n    // Adjust hue of the input color.\n    vec3 hue(vec3 color, float offset, int range_index) {\n      vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n      vec4 p = mix(vec4(color.bg, k.wz), vec4(color.gb, k.xy), step(color.b, color.g));\n      vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));\n      float d = q.x - min(q.w, q.y);\n      float e = 1e-10;\n      vec3 hsv = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                      d / (q.x + e),\n                      q.x);\n      offset = (range_index == 0) ? offset / 360.0 : offset;\n      float newHue = hsv.x + offset;\n      if(newHue < 0.0) {\n        hsv.x = newHue + 1.0;\n      } else if(newHue > 1.0) {\n        hsv.x = newHue - 1.0;\n      } else {\n        hsv.x = newHue;\n      }\n      vec4 k2 = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n      vec3 p2 = abs(fract(vec3(hsv.x) + k2.xyz) * 6.0 - k2.www);\n      vec3 rgb = hsv.z * mix(k2.xxx, clamp(p2 - k2.xxx, 0.0, 1.0), hsv.y);\n      return rgb;\n    }\n\n    void main() {\n      vec2 uv = gl_FragCoord.xy / uResolution;\n      vec2 pos = uv * 2.0 - 1.0;\n      pos.x *= uResolution.x / uResolution.y;\n      // Use the camera rotation to transform the ray, anchoring it to world space.\n      vec3 ray = normalize(uCameraRotation * vec3(pos, -1.0));\n      vec3 color = skyColor;\n      for (int i = 0; i < 12; i++) {\n        if(i >= layersCount) break;\n        float currentScale = layerScale + float(i) * layerScaleStep;\n        vec3 samplePos = ray * currentScale;\n        vec2 voro = voronoi(samplePos);\n        vec3 rnd = hash(vec3(voro.y));\n        #ifdef USE_TWINKLE\n          float twinkle = sin(uTime * PI * starTwinkleSpeed + rnd.x * TAU);\n          twinkle *= starTwinkleIntensity;\n          float star = smoothstep(starIntensity + starIntensity * twinkle, 0.0, voro.x);\n        #else\n          float star = smoothstep(starIntensity, 0.0, voro.x);\n        #endif\n        vec3 starColor = star * hue((skyColor + starBaseColor), rnd.y * starHueOffset, 1);\n        color += starColor;\n      }\n      gl_FragColor = vec4(color, 1.0);\n    }\n  ",depthWrite:!1,depthTest:!1});